Komunikacja strumieniowa - serwer
1. utworzenie gniazda
2. zarejestrowanie lokalizacji/adresu
3.zmiana trybu na pasywny
4. oczekiwanie na połącznienie/akcepatacja połączenia
    -> powstaje nowe gniazdo
5. realizacja usługi
    -> oczyt/zapis informacji
6. zamkniecie połaczenia (co dalej?) jeżeli ma dzialac w kolko to zamykamy polaczenie ktore wysyla

int socekt(int domain, int type, int protocol)
    ->#include <sys/socket.h>
    Socket Domain /Address Faminy:
        AF_UNIX, AF_LOCAL (takie same)
        AF_INET, AF_INET6
    Socket type:
        SOCK_STREAM (przez potoki TCP)
        SOCK_DGRAM (przez UDP)

1. sock_fd = socket(AF_INET, SOCK_STREAM, 0); -> ostatni parametr domena gniazd, domyslnie
if sock_fd == -1 to błąd

2. int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
    domena      typ struktury
    AF_INET     atruct sockaddr_in

    struct sockaddr_in
#include <netinet/in.h>
    struct sockaddr_in { sa_family_t sin_family (AF_INET)
                            port
                            ip (jako liczba)i}
    struct sockaddr_in A = (AF_INET, 12345, inet_addr("127.0.0.1"));
    inet_addr - nie zalecane (str to lepiej)
    bind(sock_fd, (struct soackaddr *)&addr, sizeof()

3. int listen(int sockfd, int backlog)
    if(listen() == -1) -> error

4. int accept(int sockfd, struct sockaddr* addr, socklen_t *addrlen);
    struct sockaddr_in B;
    socklen_t Blen;

    int new_fd = accept(scok_fd, struct adockaddr*)&B, &Blen);
    if(new_fd == -1)

5. read(...) / write(...)

ssize_t recv(int sockfd, void* buf, size_t len, int flags) // jka mamy potrzeby na użycie flag
ssize_t send(int sockfd, const void* buf, size_t len, int flags);

inr close(int fd); //zamkniecie calkowietei zwolnienie miejsca
# inclde <sys/socket.h>
int shutdown(int sockfd, int how) //lagodne zamkniecie, jeszcze istnieje deskryptor
    SHUT_RD
    SHUT_WR
    SHUT_RDWR

/ * * * * * * * * * * * * * * * * * * * * * * *
CWICZENIA 17.09.2019

Komunikacja strumieniowa - klient:
1. utworzenie gniazda
2. nawiazanie polaczenia
3. korzystamoe z usług serwera -> odczyt/zapis informacji
4. zamknięcie połączenia

Nawiazanie polaczenia:
int connect(int sockfd, const struct
żeby nawiązać połączenie trzeba znać lokalizację usługi (serwera)

Komunikacja datagramowa
serwer:
1. utworzenie gniazda
2. zarejesrowanie lokalizacji
3. realizacja usług -> odbieranie i wysyłanie datagramów (pakierów)
4. zakmnięcie gniazda
nie ma akceptacji i czekania, mamy gniazdo i z niego "wypadają" pakiety

różnice z komunikacją strumieniową:
 1. brak połączeń -> datagramy przychodzą niezależnie z dowolnych źródeł
 2. brak strumienia -> datagray są od siebie niezależne
    ->program jest odpowiedzialny za łączenie je w logiczną całość
    -> każdy wysyłany datagram musi być zaopatrzony w adres odbiorcy
wysyłanie datagramów:
ssize_t sendto(int sockfd, const void *buf...)
ssize_t recvfrom(int sockfd, ) miejsce na infrmacje kto nam przysłal -> nie można ich zastąpnić send

//afunix, aflocal -> domena lokalna

Interfejs gniazd domena lokalna
->tworzenie gnazd AF_UNIX (zamiast inet)
można uzywać strumieniowej jak i datagramowej komunikacji
AF_UNIX -> sockaddr_un
 ->indetyfinatora
 w drugim polu podajemy ścieżke, która nie prowadzi do żadnego pliku, ostatni elemnt ma być miejscem, kßóre nie istnieje w katalogu
sciezka 108 znaków z zerem na końcu
sun_path -> lancuch znakowy '\0'
->poprawna sciezka
->nieistniejacy plik
const char* PTH = "my_socket";
struct sockaddr_un ADDR;
ADDR.sun_family = AF_UNIX;

strncpy(ADDR.sun_path, PTH, UNIX_PATH_MAX);

//ADDR.sun_path(UNIX_PATH_MAX-1) = '\0'; //dla bezpieczenstwa
unlink(PTH);

rejestracja bind -> nie ma więcej różnic

używanie systemu plików do przechowywania socketów niesie ze sobbą problemy : brutalne morderstwo pozostawia plik socketowy -> wymyślono gniazda anonimowe w domenie unix -> socket z adresami abstrakcyjnymi (nie zostaje ślad w systemie plików)
    ->sciezka zaczyna się od zera (wszystkie 108 znaków indentyfikuja abstrakcyjny adres)
